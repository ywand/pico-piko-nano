<!DOCTYPE html>
<html lang="ja" class="uk-height-viewport">

<head>
  <meta charset="utf-8">
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-Z4TTFVRR0Y"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-Z4TTFVRR0Y');
  </script>
  <title>blockBreaking | Pico-Piko-Nano</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <link rel="stylesheet" type="text/css" href="../lib/uikit/css/uikit.min.css" />
  <script src="../lib/p5/p5.min.js"></script>
  <script src="../lib/p5/p5.play.js"></script>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      /* ← 縦スクロール禁止 */
      touch-action: none;
      /* ← スワイプ操作無効 */
      background: #000;
    }
  </style>
</head>

<body>
  <div class="uk-background-muted">blockBreaking | <a href="/">Pico-Piko-Nano</a></div>
  <script type="text/javascript">
    let balls
    let blocks
    let stage = 1
    let remCount = 0
    let remPoint = 0
    let stageBonus = 0
    let frameCount = 0
    let highScore_flag = false
    const ADD_BLOCK_NUM = 2
    const SPEED = 8
    const DEBUG = false
    const SIZE = 10
    const MAX_STAGE = 5
    const TEXT_SIZE = 14
    const TEXT_SIZE_BIG = 24
    const REM_BLOCK_POINT = 2
    const MISS_BALL_POINT = 2

    const initCanvas = () => {
      const WH = windowHeight * 1.00 - 40
      const WW = windowWidth * 1.00
      //const WH = min(windowWidth * 0.98, windowHeight * 0.98)
      //const WW = min(windowWidth * 0.98, windowHeight * 0.98)
      createCanvas(WW, WH)
      frameRate(30)
    }

    const initSpr = () => {
      bar = createSprite(width / 2, height * 0.9, SIZE * 10, SIZE)
      bar.shapeColor = color(255)
      bar.setCollider(
        "rectangle",
        0, 0,
        bar.width + 4,
        bar.height + 4
      )
      bar.debug = DEBUG
    }
    const initBall = () => {
      let ball
      if (!balls) balls = new Group()
      ball = createSprite(bar.position.x, height * 0.6, SIZE, SIZE)
      ball.shapeColor = color(255)
      ball.velocity.y = SPEED
      ball.limitSpeed(SPEED)
      balls.add(ball)
      ball.debug = DEBUG
      //ball.immovable = true
    }
    const initBlock = () => {
      let COL = 1 + stage * ADD_BLOCK_NUM
      let ROW = 1 + stage * ADD_BLOCK_NUM
      const BW = width / COL
      const BH = height / 2 / ROW
      blocks = new Group()
      for (i = 0; i < COL; i++) {
        for (j = 0; j < ROW; j++) {
          const block = createSprite(BW * i + BW / 2, BH * j + BH / 2, BW, BH)
          block._dead = false
          block.visible = true
          block.setCollider(
            "rectangle",
            0, 0,
            block.width + 4,
            block.height + 4
          )
          block.debug = DEBUG
          blocks.add(block)
        }
      }
    }

    //p5.js 初期化関数
    var setup = () => {
      console.log('setup start')
      initCanvas()
      initSpr()
      getHightScore()
      initBall()
      initBlock()
      console.log('setup end')
    }

    let highScore = {
      point: 0,
      date: "",
    }

    //ハイスコア取得
    const getHightScore = () => {
      highScore.point = localStorage.getItem("blockBreaking_HightScore_point")
      highScore.date = localStorage.getItem("blockBreaking_HightScore_date")
      if (highScore.point == null) {
        //初回ゲーム起動時にハイスコアの設定がない場合に初期値設定
        setHightScore(0, "")
      }
    }
    //ハイスコア設定
    const setHightScore = (point, date) => {
      localStorage.setItem("blockBreaking_HightScore_point", point)
      localStorage.setItem("blockBreaking_HightScore_date", date)
    }

    //更新処理
    const update = () => {
      frameCount++
      mousePos()
      areaCheck()
      ballsReset()
      blockCollision()
      hitBar()
      stageClear()
    }

    //ボールの判定初期化
    const ballsReset = () => {
      balls.forEach(ball => {
        ball._hitBar = false
        ball._hitBlock = 0
      })
    }

    //ボールの位置判定
    const areaCheck = () => {
      balls.forEach(ball => {
        if (ball.position.x >= width) {
          ball.position.x = width
          ball.velocity.x *= -1
        }
        else if (ball.position.x <= 0) {
          ball.position.x = 0
          ball.velocity.x *= -1
        }
        if (ball.position.y >= height) {
          ball.position.y = height
          ball.velocity.y *= -1

          //ボールが地面についたときミスとしてポイントをマイナス
          if (blocks.length > 0) {
            remPoint -= MISS_BALL_POINT
          }
        }
        else if (ball.position.y <= 0) {
          ball.position.y = 0
          ball.velocity.y *= -1
        }
      })
    }

    const swing = (spr1, spr2) => {
      spr1.overlap(spr2, () => {
        spr1.velocity.x = abs(spr1.position.x - spr2.position.x) / (spr2.width / 2) * SPEED
        if (spr1.position.x < spr2.position.x) {
          spr1.velocity.x *= -1
        }
      })
    }

    const hitBar = () => {
      //バーとの衝突判定
      balls.forEach(ball => {
        if (ball.overlap(bar)) {
          if (ball._hitBar == true) return
          if (ball.position.x < bar.position.x) {
            swing(ball, bar)
            ball._hitBar = true
          }
          else if (ball.position.x > bar.position.x) {
            swing(ball, bar)
            ball._hitBar = true
          }
          else {
            ball.velocity.x = 0
          }
          ball.velocity.y *= -1
        }
      })
    }

    const blockCollision = () => {
      const BLOCK_CHECK_Y = height * 0.6
      for (let i = 0; i < balls.length; i++) {
        let ball = balls[i]
        if (ball.position.y > BLOCK_CHECK_Y) {
          continue
        }

        //ブロックとの衝突判定
        ball.overlap(blocks, (ball, block) => {
          //if (ball._hitBlock > 10) return
          if (ball._hitBar) return

          ball._hitBlock++
          if (ball._hitBlock == 1) {
            ball.velocity.y *= -1
          }
          block.visible = false
          block._dead = true
          remCount++
          remPoint += 2 + stageBonus
        })
      }
      //ブロック削除
      for (let i = blocks.length - 1; i >= 0; i--) {
        const block = blocks[i]
        if (block._dead) {
          block.remove()
        }
      }
    }

    const stageClear = () => {
      //ブロックが無くなったら初期化
      if (blocks.length == 0) {
        if (stage < MAX_STAGE) {
          stage++
          initBlock()
          initBall()
          stageBonus = Math.round(stage / 5)
        } else {
          gameClear()
        }
      }
    }


    const gameClear = () => {
      if (stage >= MAX_STAGE) {
        fill(255)
        textSize(TEXT_SIZE_BIG)
        text("ゲームクリア！", 0, height / 2)
        text("もう一度遊ぶ場合はリロード", 0, height / 2 + TEXT_SIZE_BIG)

        //ハイスコア判定
        if (highScore.point < remPoint) {
          const now = new Date()
          const strYMD =
            now.getFullYear() + "/" +
            (now.getMonth() + 1).toString().padStart(2, "0") + "/" +
            now.getDate().toString().padStart(2, "0")
          setHightScore(remPoint, strYMD)
          highScore_flag = true
          getHightScore()
          console.log("最高得点更新:", remPoint, strYMD)
        }
        if (highScore_flag) {
          text("最高得点を更新しました！！", 0, height / 2 - TEXT_SIZE_BIG)
        }
      }
    }

    // マウス位置でバーを移動
    const mousePos = () => {
      bar.position.x = mouseX
      if (bar.position.x > width) {
        bar.position.x = width
      }
      else if (bar.position.x < 0) {
        bar.position.x = 0
      }
    }
    var mousePressed = () => {
    }

    //p5.js 描画ループ関数
    var draw = () => {
      background(0)
      update()
      drawSprites()

      //background(0);
      textSize(TEXT_SIZE)
      fill(255)

      let gameinfo = "残箱：" + blocks.length + "／崩箱：" + remCount + "／点：" + remPoint + "／面：" + stage
      text(gameinfo, 10, height - TEXT_SIZE)
      text("最高得点：" + highScore.point + "／記録日：" + highScore.date, 10, height)
      text(Math.round(frameCount / 30), 0, TEXT_SIZE)

    }
  </script>
  <footer></footer>
</body>

</html>