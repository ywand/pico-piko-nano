<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-Z4TTFVRR0Y"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-Z4TTFVRR0Y');
  </script>
  <link rel="stylesheet" href="../style/style.css">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>カブーンでジャンプ │ Pico-Piko-Nano</title>
  <meta name="description" content="ミニゲームよりも小さな自作ゲーム集。">
  <meta name="robots" content="index, follow">
  <script src="https://kit.fontawesome.com/231789a504.js" crossorigin="anonymous"></script>
  <link rel="icon" href="/favicon.ico">
  <link rel="icon" type="image/png" href="/favicon-512.png">
</head>
<body>
  <div class="wrapper">
    <header>
      <div class="header">
        <h1 class="font-normal ">カブーンでジャンプ │ <a href="/">Pico-Piko-Nano</a></h1>
      </div>
    </header>
    <div id="main">
      <script type="module">
        import kaboom from "https://unpkg.com/kaboom@3000.0.1/dist/kaboom.mjs";

        let touchLeft = false;
        let touchRight = false;
        const DEBUG = false;

        // 親要素のサイズを取得
        const container = document.getElementById("main");
        const cw = container.clientWidth;
        const ch = container.clientHeight;
        const cv = document.createElement("canvas");
        container.appendChild(cv);
        kaboom({
          width: cw,
          height: ch,
          canvas: cv,  // 親要素にキャンバスを埋め込む
          background: [240, 240, 240], // 空色
          gravity: 1000, // ← ここで設定
        });
        cv.tabIndex = 0;
        cv.focus();
        setGravity(1000);
        loadSprite("bean", "../assets/bean.png");


        const TILE_SIZE = 32;
        const tileDef = {
          "■": { solid: true, color: rgb(80, 80, 80) },   // 壁
          "宝": { solid: false, color: rgb(255, 200, 50) },
          "始": { start: true },
          "終": { solid: true, color: rgb(255, 80, 80) },
          "□": null,
        };
        const strMap = [
          "■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■",
          "■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■",
          "■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□■□□□□□□□□□□□□□□■",
          "■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□■終□□□□□□□□□□□□□■",
          "■宝□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□■■■□□□□□□□□□□□□■",
          "■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□■□□□■□■□□□□□□□□■",
          "■□□□■□□□□□□□□□□□□□□□□□□□□□□□□□□■□□■□□□□□□□□■□□□□□■",
          "■□□□□□□■□□□□□□□□□□□□□□□□□□□□□□□□□□■□□□□□□□□□□□□□□■",
          "■■□□□□□□□□□□□□□□□□■□□□□■□□□□□■■■□□■■■■■■■■■■■■□□□■",
          "■□□□□□□□□□■□□■□□■□□□□■□□□□■□□□□■□□■□□□□□□□□□□■■□□■",
          "■□□□□□□■□□□□□□□□□□□□□□□□□□□□□□□■□□■□□□□□□□□□□□□□□■",
          "■■□□□□□□□□□□□□□□□□□□□□□□□□□□□□□■□□■□□□□□□□□□□□□□■■",
          "■□□□□□■□□□□□□□□□□□□□□□□□□□□□□□□■□□■□□□■■■□□□□□□□□■",
          "■□□□□□□□■□□□□■□□□□□□□□□□□□□□□□□■□□■□□□□■□□□□□□■□□■",
          "■宝□□□□□□□□■■■□□□■□□□□□□□□□□□□□□■□□■□■□□■□□□□□□□□□■",
          "■■□□□□□□□□□□□□□□□□□■□□□□□□□□□□□■□□■□□□■□□□□□□□□□■■",
          "■□□□□□□□□□□□□□□■□□□□□□■□□■□□□□□■□□■□□□■宝□□□□□□□□□■",
          "■□□■□■□□□□□□□□■□□□□□□□□□□□□■□□□■□□■□■□□■□□■□□■□□□■",
          "■□□□□□□□□■□□□□□始□□□□■■■□□□□□□□■■□□■□□□□■□□■□□■□□□■",
          "■■□□□□□□□□□□□□□□□□■■■□■■■■□□□□□■□□■□□□□■□□■□□■□□□■",
          "■■■□□□□□□□■□■□□□□■■■□宝□□□□□□□□□■□□□□□□□□□□□□□□□□□■",
          "■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■",
          "■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■",
          "■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■",
          "■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■",
          "■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■",
          "■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■",
          "■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■",
        ]

        function createMap() {
          let startPos = vec2(0, 0);

          strMap.forEach((row, y) => {
            [...row].forEach((ch, x) => {
              const def = tileDef[ch];
              if (!def) return;

              const px = x * TILE_SIZE;
              const py = y * TILE_SIZE;

              // 壁などの地形
              if (def.solid) {
                add([
                  rect(TILE_SIZE, TILE_SIZE),
                  pos(px, py),
                  area(),
                  body({ isStatic: true }),
                  color(def.color),
                ]);
                def.isStatic = true;
              }

              // 宝
              if (ch === "宝") {
                add([
                  rect(TILE_SIZE * 0.6, TILE_SIZE * 0.6),
                  pos(px + TILE_SIZE * 0.2, py + TILE_SIZE * 0.2),
                  area(),
                  color(def.color),
                  "treasure",
                ]);
              }
              if (ch === "終") {
                add([
                  rect(TILE_SIZE * 0.6, TILE_SIZE * 0.6),
                  pos(px + TILE_SIZE * 0.2, py + TILE_SIZE * 0.2),
                  area(),
                  color(def.color),
                  "goal",
                ]);
              }

              // スタート位置
              if (def.start) {
                startPos = vec2(
                  px + TILE_SIZE / 2,
                  py + TILE_SIZE / 2
                );
              }
            });
          });
          return startPos;
        }

        // 文字を追加
        let tx = 0;
        let ty = 0;
        const game_info = add([
          text("height:" + height().toFixed(1)
            + "\nwidth:" + width().toFixed(1)
            + "\ntx:" + tx
            + "\nty:" + ty
            , {
              size: 14,       // 文字サイズ
              font: "sinko",  // フォント名
              width: 100,     // 幅（折り返し用）
              align: "left" // 中央揃え
            }),
          pos(0, 0),      // 画面座標
          color(10, 10, 10), // 文字色
        ]);

        game_info.onUpdate(() => {
          //console.log("onUp:" + tx + "/" + ty);
          game_info.text = "height:" + height().toFixed(1)
            + "\nwidth:" + width().toFixed(1)
            + "\ntx:" + tx
            + "\nty:" + ty
        });

        //マップ生成// マップ生成
        const startPos = createMap();

        //プレイヤー追加
        const player = add([
          sprite("bean"),
          area(),
          pos(startPos.clone()),
          body(),
          scale(0.5),  // ← ここでscaleを初期化
        ]);
        player.origin = "center";

        //宝入手でスピードやジャンプ力アップ
        let speed = 150;

        const input = {
          left: false,
          right: false,
          jump: false,
          down: false,
        }
        let oldinput = {
          left: false,
          right: false,
          jump: false,
          down: false,
        }

        function inputLog() {
          if (DEBUG) {
            if (
              input.left !== oldinput.left ||
              input.right !== oldinput.right ||
              input.jump !== oldinput.jump ||
              input.down !== oldinput.down
            ) {
              console.log(input);
              oldinput = { ...input };
            }
          }
        }

        function updatePlayerControl() {
          inputLog();
          if (input.left) {
            player.move(-speed, 0);
          }
          if (input.right) {
            player.move(speed, 0);
          }
          if (input.down) {
            //降下はタッチやマウスで表現出来ないため無効化
            player.move(0, speed / 2);
          }
          if (input.jump) {
            if (player.isGrounded()) {
              player.jump(speed * 2);
            }
            input.jump = false;
          }
        }

        function keyBind(keys, prop) {
          keys.forEach(k => {
            onKeyDown(k, () => input[prop] = true);
            onKeyRelease(k, () => input[prop] = false);
          });
        }

        //キー入力
        keyBind(["right", "d", "6"], "right");
        keyBind(["left", "a", "4"], "left");
        keyBind(["up", "w", "8", "space"], "jump");
        keyBind(["down", "s", "2"], "down");

        // タッチから来た最後の時刻（ms）
        let lastTouchTime = 0;

        // タッチ処理
        onTouchStart((pos) => {
          handleTouch(pos);
        });

        onTouchMove((pos) => {
          handleTouch(pos);
        });

        function handleTouch(pos) {
          const cam = camPos();
          const tposX = pos.x - cam.x + cw / 2;
          const tposY = pos.y - cam.y + ch / 2;

          if (tposX > cw * 0.7) {
            input.right = true;
          }
          else if (tposX < cw * 0.3) {
            input.left = true;
          }
          if (tposY < ch * 0.49) {
            input.jump = true;
          } else if (tposY > ch * 0.6) {
            input.down = true;
          }
        };

        onTouchEnd(() => {
          input.right = false;
          input.left = false;
          input.jump = false;
          input.down = false;
        });

        // マウスクリック処理
        onMouseDown(() => {
          const mpos = mousePos();
          if (mpos.x > cw * 0.7) {
            input.right = true;
          }
          else if (mpos.x < cw * 0.3) {
            input.left = true;
          }
          if (mpos.y < ch * 0.49) {
            input.jump = true;
          } else if (mpos.y > ch * 0.6) {
            input.down = true;
          }
        });

        onMouseRelease(() => {
          input.right = false;
          input.left = false;
          input.jump = false;
          input.down = false;
        });

        //プレイヤー状態の更新
        let groundedY = null

        player.onUpdate(() => {
          if (player.isGrounded()) {
            if (groundedY === null) {
              groundedY = Math.round(player.pos.y)
            }
            player.pos.y = groundedY
          } else {
            groundedY = null
          }

          const target = player.pos;
          const smooth = 6; // 小さいほどゆっくり（2〜6が目安）
          camPos(
            camPos().lerp(target, smooth * dt())
          );

          updatePlayerControl();
          PlayerCollideCheck();
        })

        function PlayerCollideCheck() {
          player.onCollide("treasure", (t) => {
            if (t.collected) return;
            t.collected = true;
            speed += 30;            // スピード上昇
            destroy(t);             // 宝を消す
            debug.log("speed up: " + speed);
          });
        }


        function createDebugPlayerPos() {
          if (DEBUG == false) return
          // 文字を追加
          let strPpos = "pX: " + Math.floor(player.pos.x) + " / pY: " + Math.floor(player.pos.y);

          const ppos = add([
            text(strPpos, {
              size: 12,       // 文字サイズ
              font: "sinko",  // フォント名
              width: 100,     // 幅（折り返し用）
              align: "left" // 中央揃え
            }),
            pos(player.pos.x - player.width / 2, player.pos.y - player.height / 2),      // 画面座標
            color(10, 10, 10), // 文字色
          ]);
          ppos.onUpdate(() => {
            // pos はオブジェクトなので代入で更新
            ppos.pos.x = player.pos.x - player.width / 2;
            ppos.pos.y = player.pos.y - player.height / 2;

            // 文字列も更新したい場合
            strPpos = "pX: " + Math.floor(player.pos.x) + " / pY: " + Math.floor(player.pos.y);
            ppos.text = strPpos;
          });
        }
        createDebugPlayerPos();

      </script>

    </div>

    <footer>
    </footer>
  </div>
  </div>
</body>
</html>